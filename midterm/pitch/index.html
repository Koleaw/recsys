<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Steam EDA (UCSD) — In-Browser (with Debug)</title>
  <style>
    :root{--bg:#f4f7f6;--card:#fff;--ink:#0f172a;--muted:#64748b;--accent:#2563eb;--ring:rgba(37,99,235,.35);--shadow:0 10px 30px rgba(2,6,23,.08);--radius:16px}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink)}
    main{max-width:1080px;margin:32px auto;padding:20px;background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow)}
    h1{margin:0 0 6px} p.lead{margin:0 0 18px;color:var(--muted)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:16px} @media(max-width:960px){.row{grid-template-columns:1fr}}
    .panel{border:1px solid #e5e7eb;border-radius:12px;padding:14px;background:#fff}
    .drop{border:2px dashed #cbd5e1;border-radius:12px;padding:16px;text-align:center;color:#475569;background:#f8fafc}
    .drop.drag{background:#eef2ff;border-color:#93c5fd}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;align-items:center}
    button{background:var(--accent);color:#fff;border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
    button.secondary{background:#e5e7eb;color:#111827}
    button:disabled{opacity:.6;cursor:not-allowed}
    input[type="number"]{padding:8px 10px;border:1px solid #e5e7eb;border-radius:8px;outline:none;width:140px}
    input[type="number"]:focus{border-color:var(--accent);box-shadow:0 0 0 4px var(--ring)}
    label.chk{display:flex;gap:8px;align-items:center;font-size:.95rem;color:#0f172a}
    table{width:100%;border-collapse:collapse;margin-top:8px} th,td{padding:8px 10px;border-bottom:1px solid #e5e7eb;text-align:left}
    th{background:#f1f5f9}
    .status{padding:10px 12px;background:#eef2ff;border:1px solid #e0e7ff;border-radius:12px;color:#1e3a8a;margin:10px 0;font-weight:700}
    canvas{width:100%;height:300px;background:#fff;border:1px solid #e5e7eb;border-radius:10px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .small{color:var(--muted);font-size:.9rem}
    details{margin-top:14px;border:1px solid #e5e7eb;border-radius:10px;background:#fafafa}
    details>summary{cursor:pointer;padding:10px 12px;font-weight:700}
    pre{margin:0;padding:12px 12px 16px;max-height:280px;overflow:auto;background:#0b1020;color:#e2e8f0;border-bottom-left-radius:10px;border-bottom-right-radius:10px}
    .warn{color:#b45309}
    .ok{color:#166534}
  </style>
</head>
<body>
  <main>
    <h1>Steam EDA (UCSD) — runs fully in the browser</h1>
    <p class="lead">Single source of truth: <span class="mono">UCSD Steam Video Game and Bundle Data</span>. Drop two files from the same dataset: <em>Reviews</em> (JSON/JSONL or <code>.json.gz</code>) and <em>Item metadata</em> (JSON/JSONL or <code>.json.gz</code>). We compute small aggregates for slides: sizes, user activity, item popularity, genres. <span class="warn">If numbers are zeros, open the Debug panel below.</span></p>

    <div class="panel">
      <div class="controls">
        <label>Max interactions (for speed): <input id="limit" type="number" value="300000" min="10000" step="10000"></label>
        <label class="chk"><input id="debug" type="checkbox"> Debug mode (log schema + first objects)</label>
        <button id="btn-run">Run EDA</button>
        <button id="btn-reset" class="secondary">Reset</button>
        <button id="btn-export" class="secondary" disabled>Export CSV</button>
      </div>
      <div class="row">
        <div class="panel">
          <h3>Reviews (JSON/JSONL/.gz)</h3>
          <div id="drop-rev" class="drop">Drop your reviews file here (or click)<br><small class="small">Accepted: .json, .jsonl, .json.gz</small></div>
          <input id="file-rev" type="file" accept=".json,.jsonl,.gz" hidden>
          <div id="rev-name" class="small"></div>
        </div>
        <div class="panel">
          <h3>Item metadata (JSON/JSONL/.gz)</h3>
          <div id="drop-itm" class="drop">Drop your items/metadata file here (or click)<br><small class="small">Accepted: .json, .jsonl, .json.gz</small></div>
          <input id="file-itm" type="file" accept=".json,.jsonl,.gz" hidden>
          <div id="itm-name" class="small"></div>
        </div>
      </div>
      <div id="status" class="status">Waiting for files…</div>
      <details id="dbg">
        <summary>Debug log (click to open)</summary>
        <pre id="log"></pre>
      </details>
    </div>

    <div class="row">
      <div class="panel">
        <h3>Headline</h3>
        <table id="tbl-head"><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="panel">
        <h3>Genres (Top-20)</h3>
        <canvas id="chart-genres" width="500" height="300"></canvas>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <div class="panel">
        <h3>User activity (interactions per user)</h3>
        <canvas id="chart-users" width="500" height="300"></canvas>
      </div>
      <div class="panel">
        <h3>Item popularity (interactions per item)</h3>
        <canvas id="chart-items" width="500" height="300"></canvas>
      </div>
    </div>
  </main>

  <script>
    const $ = (id)=>document.getElementById(id);
    const setStatus = (s)=>{$('status').textContent = s;};
    const log = (msg)=>{$('log').textContent += msg + "\\n";};

    function wireDrop(elDrop, elInput, onFile){
      elDrop.addEventListener('click', ()=>elInput.click());
      ['dragenter','dragover'].forEach(ev=>elDrop.addEventListener(ev, e=>{e.preventDefault(); elDrop.classList.add('drag');}));
      ['dragleave','drop'].forEach(ev=>elDrop.addEventListener(ev, e=>{e.preventDefault(); elDrop.classList.remove('drag');}));
      elDrop.addEventListener('drop', e=>{
        const f = e.dataTransfer.files?.[0]; if(f) onFile(f);
      });
      elInput.addEventListener('change', e=>{
        const f = e.target.files?.[0]; if(f) onFile(f);
      });
    }

    async function* streamText(file){
      const ds = file.name.endsWith('.gz') ? new DecompressionStream('gzip') : null;
      const stream = ds ? file.stream().pipeThrough(ds) : file.stream();
      const textStream = stream.pipeThrough(new TextDecoderStream());
      const reader = textStream.getReader();
      while(true){
        const {value, done} = await reader.read();
        if(done) break;
        yield value;
      }
    }

    async function* streamJSONL(file){
      let buf = '';
      for await (const chunk of streamText(file)){
        buf += chunk;
        let idx;
        while((idx = buf.indexOf('\\n')) >= 0){
          const line = buf.slice(0, idx).trim();
          buf = buf.slice(idx+1);
          if(!line) continue;
          try { yield JSON.parse(line); } catch(e){ log('JSONL parse error, skipping line'); }
        }
      }
      const last = buf.trim();
      if(last) { try { yield JSON.parse(last); } catch(e){ log('Tail JSONL parse error'); } }
    }

    async function* streamJSONArray(file){
      let inStr=false, esc=false, depth=0, bufObj='', seenArrayStart=false;
      for await (const chunk of streamText(file)){
        for(let i=0;i<chunk.length;i++){
          const ch = chunk[i];
          if(!seenArrayStart){
            if(/\\s/.test(ch)) continue;
            if(ch === '['){ seenArrayStart=true; continue; }
            log('Not a JSON array — will fallback to JSONL parser only.');
            return;
          }
          if(inStr){
            bufObj += ch;
            if(esc){ esc=false; }
            else if(ch==='\\\\'){ esc=true; }
            else if(ch==='"'){ inStr=false; }
            continue;
          }
          if(ch==='"'){ inStr=true; bufObj += ch; continue; }
          if(ch==='{' ){ depth++; bufObj += ch; continue; }
          if(ch==='}' ){ depth--; bufObj += ch;
            if(depth===0){
              try{ const obj = JSON.parse(bufObj); yield obj; }catch(e){ log('Object JSON parse error'); }
              bufObj='';
            }
            continue;
          }
          if(depth>0){ bufObj += ch; continue; }
        }
      }
    }

    async function* streamObjects(file){
      let any=false, count=0;
      for await (const o of streamJSONL(file)){ any=true; count++; if(count<=3 && $('debug').checked) log('JSONL sample '+count+': '+JSON.stringify(o).slice(0,400)); yield o; }
      if(any){ if($('debug').checked) log('Detected JSONL format.'); return; }
      count=0;
      for await (const o of streamJSONArray(file)){ count++; if(count<=3 && $('debug').checked) log('JSON array sample '+count+': '+JSON.stringify(o).slice(0,400)); yield o; }
      if(count>0 && $('debug').checked) log('Detected JSON array format.');
    }

    function guessId(obj, preferKeys){
      for(const k of preferKeys){ if(obj[k]!=null) return obj[k]; }
      // fallback: search keys like *app*id*, *item*id*, id
      const keys = Object.keys(obj);
      for(const k of keys){
        const lk = k.toLowerCase();
        const v = obj[k];
        if(v==null) continue;
        if(/id$/.test(lk) || /(app|item|game).*id/.test(lk) || /id.*(app|item|game)/.test(lk) || lk==='id'){
          if(typeof v==='number' || /^\d+$/.test(String(v))) return v;
        }
      }
      return null;
    }

    function getUserId(o){
      return guessId(o, ['user_id','user','uid']) ?? (o.author?.steamid ?? o.profile?.id ?? null);
    }
    function getItemId(o){
      return guessId(o, ['item_id','app_id','appid','product_id','game_id','appID']);
    }
    function getRecommended(o){
      const v = o.recommended ?? o.voted_up ?? o.recommendation ?? null;
      return v === true ? true : v === false ? false : null;
    }
    function getPlayHours(o){
      const mins = o.playtime_minutes ?? o.playtime_forever ?? o.author?.playtime_forever ?? null;
      if(mins != null) return Number(mins)/60;
      const hrs = o.hours ?? o.play_hours ?? o.playtime_hours ?? null;
      return hrs != null ? Number(hrs) : null;
    }
    function extractGenres(item){
      let g = item.genres ?? item.genre ?? item.tags ?? null;
      if(Array.isArray(g)) return g.map(x=>String(x).trim()).filter(Boolean);
      if(typeof g === 'string') return g.split(/[;,]/).map(s=>s.trim()).filter(Boolean);
      if(Array.isArray(item.categories)) return item.categories.map(x=>String(x.description||x.name||x).trim()).filter(Boolean);
      if(item.tags && typeof item.tags==='object') return Object.keys(item.tags);
      return [];
    }

    function drawBar(canvasId, labels, values, title=''){
      const cvs = $(canvasId); const ctx = cvs.getContext('2d');
      ctx.clearRect(0,0,cvs.width,cvs.height);
      const pad=40, W=cvs.width-pad*2, H=cvs.height-pad*2;
      const maxV = Math.max(1, ...values);
      ctx.strokeStyle='#cbd5e1'; ctx.strokeRect(pad,pad,W,H);
      const n = values.length;
      const bw = W / Math.max(1,n);
      for(let i=0;i<n;i++){
        const h = (values[i]/maxV)*H;
        const x = pad + i*bw + 2;
        const y = pad + (H - h);
        ctx.fillStyle = '#2563eb';
        ctx.fillRect(x, y, Math.max(1,bw-4), h);
      }
      ctx.fillStyle='#334155'; ctx.font='12px system-ui';
      if(n<=20){
        for(let i=0;i<n;i++){
          const x = pad + i*(W/Math.max(1,n)) + (W/Math.max(1,n))/2;
          ctx.save(); ctx.translate(x, cvs.height-6); ctx.rotate(-Math.PI/4);
          ctx.fillText(String(labels[i]).slice(0,18), 0, 0);
          ctx.restore();
        }
      }
      if(title){ ctx.fillText(title, pad, pad-10); }
    }

    let REV=null, ITM=null;
    wireDrop($('drop-rev'), $('file-rev'), f=>{ REV=f; $('rev-name').textContent = f.name + ' (' + (f.size/1e6).toFixed(1) + ' MB)'; setStatus('Reviews file is set.'); });
    wireDrop($('drop-itm'), $('file-itm'), f=>{ ITM=f; $('itm-name').textContent = f.name + ' (' + (f.size/1e6).toFixed(1) + ' MB)'; setStatus('Item metadata file is set.'); });

    $('btn-reset').onclick = ()=>{
      REV=ITM=null; $('rev-name').textContent=''; $('itm-name').textContent=''; setStatus('Waiting for files…');
      $('tbl-head').querySelector('tbody').innerHTML=''; drawBar('chart-genres',[],[]); drawBar('chart-users',[],[]); drawBar('chart-items',[],[]); $('btn-export').disabled=true;
      $('log').textContent='';
    };

    async function peek(file, n=3){
      const out=[]; let i=0;
      for await (const o of streamObjects(file)){ out.push(o); if(++i>=n) break; }
      return out;
    }

    $('btn-run').onclick = async ()=>{
      if(!REV || !ITM){ setStatus('Please provide both reviews and item metadata.'); return; }
      $('log').textContent='';
      const LIMIT = Math.max(10000, Number($('limit').value)||300000);
      $('btn-run').disabled=true; $('btn-export').disabled=true; setStatus('Reading item metadata…');

      if($('debug').checked){
        const p = await peek(ITM, 2);
        log('Peek items (first 2):'); p.forEach((o,i)=>log('  '+(i+1)+': '+JSON.stringify(o).slice(0,500)));
      }

      const itemGenres = new Map();
      let itemCount=0, itemIdMiss=0;
      for await (const obj of streamObjects(ITM)){
        const iid = getItemId(obj);
        if(iid==null){ itemIdMiss++; continue; }
        const gens = extractGenres(obj);
        itemGenres.set(String(iid), gens);
        itemCount++;
        if(itemCount % 5000 === 0) setStatus('Parsing items… ' + itemCount);
      }
      setStatus('Items parsed: ' + itemCount + ' (miss id: '+itemIdMiss+'). Reading reviews…');
      if($('debug').checked) log(`Items parsed=${itemCount}, id_missed=${itemIdMiss}`);

      if($('debug').checked){
        const p = await peek(REV, 2);
        log('Peek reviews (first 2):'); p.forEach((o,i)=>log('  '+(i+1)+': '+JSON.stringify(o).slice(0,500)));
      }

      const users = new Map();
      const items = new Map();
      const genres = new Map();
      let total=0, pos=0; let hoursSum=0, hoursCnt=0;
      let uniqUsers=0, uniqItems=0;
      const seenUsers = new Set(); const seenItems = new Set();
      let missU=0, missI=0;

      for await (const obj of streamObjects(REV)){
        if(total>=LIMIT) break;
        const uid = getUserId(obj); const iid = getItemId(obj);
        if(uid==null){ missU++; continue; }
        if(iid==null){ missI++; continue; }
        total++;

        if(!seenUsers.has(uid)){ seenUsers.add(uid); uniqUsers++; }
        if(!seenItems.has(iid)){ seenItems.add(iid); uniqItems++; }

        users.set(uid, 1 + (users.get(uid)||0));
        items.set(iid, 1 + (items.get(iid)||0));

        const rec = getRecommended(obj);
        const hrs = getPlayHours(obj);
        if(rec===true || (typeof hrs==='number' && hrs>=1)) pos++;
        if(typeof hrs==='number'){ hoursSum += hrs; hoursCnt++; }

        const glist = itemGenres.get(String(iid)) || [];
        for(const g of glist){ genres.set(g, 1 + (genres.get(g)||0)); }

        if(total % 20000 === 0) setStatus('Parsing reviews… ' + total + ' / ' + LIMIT);
      }

      if($('debug').checked) log(`Reviews parsed=${total}, miss_user=${missU}, miss_item=${missI}`);
      if(itemCount===0) log('⚠ No items parsed. Likely item id field did not match. Inspect "Peek items" and confirm id key.');
      if(total===0) log('⚠ No reviews parsed. Likely reviews format not recognized. Inspect "Peek reviews".');

      const posRate = total>0 ? pos/total : 0;
      const meanHours = hoursCnt>0 ? hoursSum/hoursCnt : 0;

      function hist(map, bins=[1,2,5,10,20,50,100,200,500,1000,2000]){
        const counts = new Array(bins.length).fill(0);
        for(const c of map.values()){
          let idx = bins.findIndex(b=>c<=b);
          if(idx<0) idx = bins.length-1;
          counts[idx]++;
        }
        const labels = bins.map(b=>'≤'+b);
        return {labels, counts};
      }
      const uHist = hist(users);
      const iHist = hist(items);

      const topG = [...genres.entries()].sort((a,b)=>b[1]-a[1]).slice(0,20);
      const gLabels = topG.map(x=>x[0]); const gValues = topG.map(x=>x[1]);

      const tbody = $('tbl-head').querySelector('tbody');
      const rows = [
        ['Total interactions', String(total)],
        ['Unique users', String(uniqUsers)],
        ['Unique items', String(uniqItems)],
        ['Positive share (recommended OR ≥1h)', (posRate*100).toFixed(1)+'%'],
        ['Avg playtime (where present)', meanHours.toFixed(2)+' h'],
        ['Items parsed (metadata)', String(itemCount)],
        ['Missed user ids (reviews)', String(missU)],
        ['Missed item ids (reviews)', String(missI)]
      ];
      tbody.innerHTML = rows.map(r=>'<tr><td>'+r[0]+'</td><td>'+r[1]+'</td></tr>').join('');

      drawBar('chart-genres', gLabels, gValues);
      drawBar('chart-users', uHist.labels, uHist.counts);
      drawBar('chart-items', iHist.labels, iHist.counts);

      setStatus('Done. Check Debug for schema notes. You can export CSV.');
      $('btn-export').disabled=false; $('btn-run').disabled=false;

      window.__eda_export = {
        headline: rows,
        user_activity: [['bin','users']].concat(uHist.labels.map((l,i)=>[l, uHist.counts[i]])),
        item_popularity: [['bin','items']].concat(iHist.labels.map((l,i)=>[l, iHist.counts[i]])),
        genre_counts: [['genre','count']].concat(topG.map(([g,c])=>[g,c])),
      };
    };

    $('btn-export').onclick = ()=>{
      if(!window.__eda_export) return;
      const files = window.__eda_export;
      function toCSV(rows){ return rows.map(r=>r.map(x=>String(x).replace(/"/g,'""')).join(',')).join('\\n'); }
      const z = [
        ['headline.csv', toCSV([['metric','value']].concat(files.headline))],
        ['user_activity.csv', toCSV(files.user_activity)],
        ['item_popularity.csv', toCSV(files.item_popularity)],
        ['genre_counts.csv', toCSV(files.genre_counts)],
      ];
      for(const [name, csv] of z){
        const a = document.createElement('a');
        a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
        a.download = name;
        a.click();
      }
    };
  </script>
</body>
</html>
