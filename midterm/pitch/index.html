<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Steam EDA — Single-Source (UCSD) — In‑Browser</title>
  <style>
    :root{--bg:#f4f7f6;--card:#fff;--ink:#0f172a;--muted:#64748b;--accent:#2563eb;--ring:rgba(37,99,235,.35);--shadow:0 10px 30px rgba(2,6,23,.08);--radius:16px}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink)}
    main{max-width:1080px;margin:32px auto;padding:20px;background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow)}
    h1{margin:0 0 6px} p.lead{margin:0 0 18px;color:var(--muted)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:16px} @media(max-width:960px){.row{grid-template-columns:1fr}}
    .panel{border:1px solid #e5e7eb;border-radius:12px;padding:14px;background:#fff}
    .drop{border:2px dashed #cbd5e1;border-radius:12px;padding:16px;text-align:center;color:#475569;background:#f8fafc}
    .drop.drag{background:#eef2ff;border-color:#93c5fd}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
    button{background:var(--accent);color:#fff;border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
    button.secondary{background:#e5e7eb;color:#111827}
    button:disabled{opacity:.6;cursor:not-allowed}
    input[type="number"]{padding:8px 10px;border:1px solid #e5e7eb;border-radius:8px;outline:none;width:120px}
    input[type="number"]:focus{border-color:var(--accent);box-shadow:0 0 0 4px var(--ring)}
    table{width:100%;border-collapse:collapse;margin-top:8px} th,td{padding:8px 10px;border-bottom:1px solid #e5e7eb;text-align:left}
    th{background:#f1f5f9}
    .status{padding:10px 12px;background:#eef2ff;border:1px solid #e0e7ff;border-radius:12px;color:#1e3a8a;margin:10px 0;font-weight:700}
    canvas{width:100%;height:300px;background:#fff;border:1px solid #e5e7eb;border-radius:10px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .small{color:var(--muted);font-size:.9rem}
  </style>
</head>
<body>
  <main>
    <h1>Steam EDA (UCSD) — полностью в браузере</h1>
    <p class="lead">Один источник: <span class="mono">UCSD Steam Video Game and Bundle Data</span>. Загрузи два файла этого же набора: <em>Reviews (JSON/JSONL/.gz)</em> и <em>Item metadata (JSON/JSONL/.gz)</em>. Мы считаем только агрегаты для слайдов: размеры, активность пользователей, популярность игр, жанры.</p>

    <div class="panel">
      <div class="controls">
        <label>Лимит взаимодействий (для скорости): <input id="limit" type="number" value="300000" min="10000" step="10000"></label>
        <button id="btn-run">Запустить EDA</button>
        <button id="btn-reset" class="secondary">Сброс</button>
        <button id="btn-export" class="secondary" disabled>Скачать CSV-агрегаты</button>
      </div>
      <div class="row">
        <div class="panel">
          <h3>Reviews (JSON/JSONL/.gz)</h3>
          <div id="drop-rev" class="drop">Перетащи сюда файл reviews (или нажми) <br><small class="small">Поддерживаются .json, .jsonl, .json.gz</small></div>
          <input id="file-rev" type="file" accept=".json,.jsonl,.gz" hidden>
          <div id="rev-name" class="small"></div>
        </div>
        <div class="panel">
          <h3>Item metadata (JSON/JSONL/.gz)</h3>
          <div id="drop-itm" class="drop">Перетащи сюда файл items/metadata (или нажми) <br><small class="small">Поддерживаются .json, .jsonl, .json.gz</small></div>
          <input id="file-itm" type="file" accept=".json,.jsonl,.gz" hidden>
          <div id="itm-name" class="small"></div>
        </div>
      </div>
      <div id="status" class="status">Файлы не загружены.</div>
    </div>

    <div class="row">
      <div class="panel">
        <h3>Сводка</h3>
        <table id="tbl-head"><thead><tr><th>Показатель</th><th>Значение</th></tr></thead><tbody></tbody></table>
      </div>
      <div class="panel">
        <h3>Жанры (топ‑20)</h3>
        <canvas id="chart-genres" width="500" height="300"></canvas>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <div class="panel">
        <h3>Активность пользователей (сколько взаимодействий на пользователя)</h3>
        <canvas id="chart-users" width="500" height="300"></canvas>
      </div>
      <div class="panel">
        <h3>Популярность игр (сколько взаимодействий на игру)</h3>
        <canvas id="chart-items" width="500" height="300"></canvas>
      </div>
    </div>
  </main>

  <script>
    // ---------- helpers: UI ----------
    const $ = (id)=>document.getElementById(id);
    const status = (s)=>{$('status').textContent = s;};

    function wireDrop(elDrop, elInput, onFile){
      elDrop.addEventListener('click', ()=>elInput.click());
      ['dragenter','dragover'].forEach(ev=>elDrop.addEventListener(ev, e=>{e.preventDefault(); elDrop.classList.add('drag');}));
      ['dragleave','drop'].forEach(ev=>elDrop.addEventListener(ev, e=>{e.preventDefault(); elDrop.classList.remove('drag');}));
      elDrop.addEventListener('drop', e=>{
        const f = e.dataTransfer.files?.[0]; if(f) onFile(f);
      });
      elInput.addEventListener('change', e=>{
        const f = e.target.files?.[0]; if(f) onFile(f);
      });
    }

    // ---------- streaming parsers ----------
    async function* streamTextFromFile(file){
      // If .gz — use DecompressionStream('gzip'), else read as-is
      const ds = file.name.endsWith('.gz') ? new DecompressionStream('gzip') : null;
      const stream = ds ? file.stream().pipeThrough(ds) : file.stream();
      const textStream = stream.pipeThrough(new TextDecoderStream());
      const reader = textStream.getReader();
      while(true){
        const {value, done} = await reader.read();
        if(done) break;
        yield value;
      }
    }

    async function* streamJSONLines(file){
      // Supports JSON Lines; tolerates occasional array by splitting newlines (best-effort)
      let buf = '';
      for await (const chunk of streamTextFromFile(file)){
        buf += chunk;
        let idx;
        while((idx = buf.indexOf('\n')) >= 0){
          const line = buf.slice(0, idx).trim();
          buf = buf.slice(idx+1);
          if(!line) continue;
          try {
            const obj = JSON.parse(line);
            yield obj;
          } catch(e){
            // If the file is a JSON array, try to ignore until next newline.
            if(line.startsWith('[') || line.endsWith(']')) continue;
          }
        }
      }
      const last = buf.trim();
      if(last && last !== '[' && last !== ']'){
        try { yield JSON.parse(last); } catch(e){ /* ignore */ }
      }
    }

    // ---------- schema-agnostic extractors ----------
    function getUserId(o){
      return o.user_id ?? o.user ?? o.uid ?? o.author?.steamid ?? o.profile?.id ?? null;
    }
    function getItemId(o){
      return o.item_id ?? o.app_id ?? o.appid ?? o.product_id ?? o.game_id ?? null;
    }
    function getTimestamp(o){
      return o.timestamp ?? o.time ?? o.time_created ?? o.created ?? o.timestamp_created ?? null;
    }
    function getRecommended(o){
      const v = o.recommended ?? o.voted_up ?? o.recommendation ?? null;
      return v === true ? true : v === false ? false : null;
    }
    function getPlayHours(o){
      // minutes → hours if needed
      const mins = o.playtime_minutes ?? o.playtime_forever ?? o.author?.playtime_forever ?? null;
      if(mins != null) return Number(mins)/60;
      const hrs = o.hours ?? o.play_hours ?? o.playtime_hours ?? null;
      return hrs != null ? Number(hrs) : null;
    }
    function extractGenres(item){
      let g = item.genres ?? item.genre ?? item.tags ?? null;
      if(Array.isArray(g)) return g.map(x=>String(x).trim()).filter(Boolean);
      if(typeof g === 'string') return g.split(/[;,]/).map(s=>s.trim()).filter(Boolean);
      return [];
    }

    // ---------- charts ----------
    function drawBar(canvasId, labels, values, title=''){
      const cvs = $(canvasId); const ctx = cvs.getContext('2d');
      ctx.clearRect(0,0,cvs.width,cvs.height);
      const pad=40, W=cvs.width-pad*2, H=cvs.height-pad*2;
      const maxV = Math.max(1, ...values);
      ctx.strokeStyle='#cbd5e1'; ctx.strokeRect(pad,pad,W,H);
      const n = values.length;
      const bw = W / Math.max(1,n);
      for(let i=0;i<n;i++){
        const h = (values[i]/maxV)*H;
        const x = pad + i*bw + 2;
        const y = pad + (H - h);
        ctx.fillStyle = '#2563eb';
        ctx.fillRect(x, y, Math.max(1,bw-4), h);
      }
      ctx.fillStyle='#334155'; ctx.font='12px system-ui';
      if(n<=20){
        for(let i=0;i<n;i++){
          const x = pad + i*(W/Math.max(1,n)) + (W/Math.max(1,n))/2;
          ctx.save(); ctx.translate(x, cvs.height-6); ctx.rotate(-Math.PI/4);
          ctx.fillText(String(labels[i]).slice(0,18), 0, 0);
          ctx.restore();
        }
      }
      if(title){ ctx.fillText(title, pad, pad-10); }
    }

    // ---------- EDA core ----------
    let REV=null, ITM=null;
    wireDrop($('drop-rev'), $('file-rev'), f=>{ REV=f; $('rev-name').textContent = f.name + ' (' + (f.size/1e6).toFixed(1) + ' MB)'; status('Файл reviews загружен, ждём item metadata.'); });
    wireDrop($('drop-itm'), $('file-itm'), f=>{ ITM=f; $('itm-name').textContent = f.name + ' (' + (f.size/1e6).toFixed(1) + ' MB)'; status('Файл item metadata загружен, можно запускать.'); });

    $('btn-reset').onclick = ()=>{
      REV=ITM=null; $('rev-name').textContent=''; $('itm-name').textContent=''; status('Файлы не загружены.');
      $('tbl-head').querySelector('tbody').innerHTML=''; drawBar('chart-genres',[],[]); drawBar('chart-users',[],[]); drawBar('chart-items',[],[]); $('btn-export').disabled=true;
    };

    $('btn-run').onclick = async ()=>{
      if(!REV || !ITM){ status('Загрузите оба файла: reviews и item metadata.'); return; }
      const LIMIT = Math.max(10000, Number($('limit').value)||300000);
      $('btn-run').disabled=true; $('btn-export').disabled=true; status('Чтение item metadata…');
      // 1) Build itemId -> genres
      const itemGenres = new Map();
      let itemCount=0;
      for await (const obj of streamJSONLines(ITM)){
        const iid = getItemId(obj); if(iid==null) continue;
        const gens = extractGenres(obj);
        itemGenres.set(String(iid), gens);
        itemCount++;
        if(itemCount % 5000 === 0) status('Идёт разбор item metadata… ' + itemCount);
      }
      status('Прочитано items: ' + itemCount + '. Чтение reviews…');

      // 2) Stream reviews & aggregate
      const users = new Map(); // uid -> count
      const items = new Map(); // iid -> count
      const genres = new Map(); // genre -> count (by interactions)
      let total=0, pos=0; let hoursSum=0, hoursCnt=0;
      let uniqUsers=0, uniqItems=0;
      const seenUsers = new Set(); const seenItems = new Set();

      for await (const obj of streamJSONLines(REV)){
        if(total>=LIMIT) break;
        const uid = getUserId(obj); const iid = getItemId(obj);
        if(uid==null || iid==null) continue;
        total++;

        if(!seenUsers.has(uid)){ seenUsers.add(uid); uniqUsers++; }
        if(!seenItems.has(iid)){ seenItems.add(iid); uniqItems++; }

        users.set(uid, 1 + (users.get(uid)||0));
        items.set(iid, 1 + (items.get(iid)||0));

        const rec = getRecommended(obj);
        const hrs = getPlayHours(obj);
        if(rec===true || (typeof hrs==='number' && hrs>=1)) pos++;
        if(typeof hrs==='number'){ hoursSum += hrs; hoursCnt++; }

        const glist = itemGenres.get(String(iid)) || [];
        for(const g of glist){
          genres.set(g, 1 + (genres.get(g)||0));
        }

        if(total % 20000 === 0) status('Идёт разбор reviews… ' + total + ' / ' + LIMIT);
      }

      const posRate = total>0 ? pos/total : 0;
      const meanHours = hoursCnt>0 ? hoursSum/hoursCnt : 0;

      function histCounts(map, bins=[1,2,5,10,20,50,100,200,500,1000,2000]){
        const counts = new Array(bins.length).fill(0);
        for(const c of map.values()){
          let idx = bins.findIndex(b=>c<=b);
          if(idx<0) idx = bins.length-1;
          counts[idx]++;
        }
        const labels = bins.map(b=>'≤'+b);
        return {labels, counts};
      }
      const uHist = histCounts(users);
      const iHist = histCounts(items);

      const topG = [...genres.entries()].sort((a,b)=>b[1]-a[1]).slice(0,20);
      const gLabels = topG.map(x=>x[0]); const gValues = topG.map(x=>x[1]);

      const tbody = $('tbl-head').querySelector('tbody');
      const rows = [
        ['Всего взаимодействий', String(total)],
        ['Уникальных пользователей', String(uniqUsers)],
        ['Уникальных игр', String(uniqItems)],
        ['Доля положительных (recommended или ≥1 ч)', (posRate*100).toFixed(1)+'%'],
        ['Среднее время игры (по тем, у кого оно есть)', meanHours.toFixed(2)+' ч'],
        ['Обработано items (метаданные)', String(itemCount)],
      ];
      tbody.innerHTML = rows.map(r=>'<tr><td>'+r[0]+'</td><td>'+r[1]+'</td></tr>').join('');

      drawBar('chart-genres', gLabels, gValues);
      drawBar('chart-users', uHist.labels, uHist.counts);
      drawBar('chart-items', iHist.labels, iHist.counts);

      status('Готово: считаны агрегаты. Можно экспортировать CSV.');
      $('btn-export').disabled=false; $('btn-run').disabled=false;

      window.__eda_export = {
        headline: rows,
        user_activity: [['bin','users']].concat(uHist.labels.map((l,i)=>[l, uHist.counts[i]])),
        item_popularity: [['bin','items']].concat(iHist.labels.map((l,i)=>[l, iHist.counts[i]])),
        genre_counts: [['genre','count']].concat(topG.map(([g,c])=>[g,c])),
      };
    };

    $('btn-export').onclick = ()=>{
      if(!window.__eda_export) return;
      const files = window.__eda_export;
      function toCSV(rows){ return rows.map(r=>r.map(x=>String(x).replace(/"/g,'""')).join(',')).join('\n'); }
      const z = [
        ['headline.csv', toCSV([['metric','value']].concat(files.headline))],
        ['user_activity.csv', toCSV(files.user_activity)],
        ['item_popularity.csv', toCSV(files.item_popularity)],
        ['genre_counts.csv', toCSV(files.genre_counts)],
      ];
      for(const [name, csv] of z){
        const a = document.createElement('a');
        a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
        a.download = name;
        a.click();
      }
    };
  </script>
</body>
</html>
